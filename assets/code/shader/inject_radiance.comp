#version 430
#extension GL_ARB_shader_image_load_store : require
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(binding = 0, rgba8) uniform readonly image3D voxelAlbedo;
layout(binding = 1, rgba8) uniform readonly image3D voxelNormal;
layout(binding = 2, rgba8) uniform readonly image3D voxelEmisson;
layout(binding = 3, rgba8) uniform readonly image3D voxelRoughness;
layout(binding = 4, rgba8) uniform readonly image3D voxelMetalness;
layout(binding = 5, rgba8) uniform writeonly image3D voxelRadiance;

//计算宏
const float PI = 3.14159265f;
const float EPSILON = 1e-30;
const float SQRT_3 = 1.73205080f;

//参数
uniform vec3 viewPos;
uniform float F0;

//灯光
struct Light {
    vec3 position;
	vec3 color;
	float intensity;
};
const uint MAX_POINT_LIGHTS = 6;
uniform Light pointLight[MAX_POINT_LIGHTS];
uniform int lightCount;

//体素信息
uniform float voxelSize;
uniform float voxelScale;
uniform vec3 worldMinPoint;
uniform int volumeDimension;

uniform float traceShadowHit;

//BRDF
float D(vec3 N, vec3 H, float Roughness);
vec3 F(vec3 H, vec3 V, vec3 F0);
float G_direct(vec3 N, vec3 I, float Roughness);
float G_ibl(vec3 N, vec3 I, float Roughness);
vec3 f_Specular(vec3 N,vec3 L,vec3 H, vec3 V, float Roughness, float metalness, vec3 F0);
vec3 BRDF(vec3 albedo, vec3 N,vec3 L,vec3 H, vec3 V, float Roughness, float metalness, vec3 F0, float KD);

vec3 VoxelToWorld(ivec3 pos);
vec3 WorldToVoxel(vec3 position);
float TraceShadow(vec3 position, vec3 direction, float maxTracingDistance);
vec4 CalculatePoint(Light light, vec3 normal, vec3 position, vec3 albedo, float roughness, float metalness);
vec4 CalculateDirectLighting(vec3 position, vec3 normal, vec3 albedo, float roughness, float metalness);
vec3 EncodeNormal(vec3 normal);
vec3 DecodeNormal(vec3 normal);

void main()
{
	if(gl_GlobalInvocationID.x >= volumeDimension ||
		gl_GlobalInvocationID.y >= volumeDimension ||
		gl_GlobalInvocationID.z >= volumeDimension) return;

	ivec3 writePos = ivec3(gl_GlobalInvocationID);

	vec4 result = vec4(0.0f);

	vec4 albedo = imageLoad(voxelAlbedo, writePos);
	vec4 baseNormal = imageLoad(voxelNormal, writePos);
	vec4 emission = imageLoad(voxelEmisson, writePos);
	float metalness = imageLoad(voxelMetalness, writePos).r;
	float roughness = imageLoad(voxelRoughness, writePos).r;

    if(albedo.a < EPSILON) { return; }

    albedo.a = 0.0f;
    vec3 normal = DecodeNormal(baseNormal.xyz);

    if(any(greaterThan(albedo.rgb, vec3(0.0f))))
    {
        vec3 wsPosition = VoxelToWorld(writePos);
        result = CalculateDirectLighting(wsPosition, normal, albedo.rgb, roughness, metalness);
    }

    result.rgb += emission.rgb;
    result.a = 1.0f;

	imageStore(voxelRadiance, writePos, result);
}

vec3 VoxelToWorld(ivec3 pos)
{
    vec3 result = vec3(pos);
    result *= voxelSize;

    return result + worldMinPoint;
}

vec3 WorldToVoxel(vec3 position)
{
    vec3 voxelPos = position - worldMinPoint;
    return voxelPos * voxelScale;
}

float TraceShadow(vec3 position, vec3 direction, float maxTracingDistance) 
{
    // scaling factor
    float k = traceShadowHit * traceShadowHit;
    // navigation
    float voxelTexSize = 1.0f / volumeDimension;
    // move one voxel further to avoid self collision
    float dst = voxelTexSize * 2.0f;
    vec3 samplePos = direction * dst + position;
    // control variables
    float visibility = 0.0f;
    // accumulated sample
    float traceSample = 0.0f;

    while (visibility <= 1.0f && dst <= maxTracingDistance) 
    {
        if (samplePos.x < 0.0f || samplePos.y < 0.0f || samplePos.z < 0.0f
            || samplePos.x > 1.0f || samplePos.y > 1.0f || samplePos.z > 1.0f) 
        { 
            break; 
        }

		ivec3 voxelPos = ivec3(
			uint(WorldToVoxel(samplePos).x),
			uint(WorldToVoxel(samplePos).y),
			uint(WorldToVoxel(samplePos).z)
			);
        
        traceSample = ceil(imageLoad(voxelAlbedo, voxelPos).a) * k;

        // hard shadows mode
        if(traceSample > 1.0f - EPSILON) { return 0.0f; }

        // accumulate
        visibility += (1.0f - visibility) * traceSample / dst;
        // move further into volume
        dst += voxelTexSize;
        samplePos = direction * dst + position;
    }

    return 1.0f - visibility;
}


vec3 F(vec3 H, vec3 V, vec3 F0){
	return F0 + (1-F0)*pow(1-max(dot(H, V), 0.0), 5);
}

float G_direct(vec3 N, vec3 I, float Roughness){
	float NI = max(dot(N,I),0);
	float k = pow(Roughness+1.0f,2)/8.0f;
	return NI/(NI*(1-k)+k);
}

float G_ibl(vec3 N, vec3 I, float Roughness){
	float NI = max(dot(N,I),0);
	float alpha = Roughness*Roughness;
	float R_2 = alpha*alpha;
	float k = R_2/8.0f;
	return NI/(NI*(1-k)+k);
}

vec3 f_Specular(vec3 N,vec3 L,vec3 H, vec3 V, float Roughness, float metalness, vec3 F0){
	float NV = max(dot(V,N), 0);
	float NL = max(dot(L,N),0);
	return (D(N,H,Roughness)*F(H,V,F0)*G_direct(N,L,Roughness)*G_direct(N,V,Roughness))/(4.0f*NV*NL + 0.001f);
}


float D(vec3 N, vec3 H, float Roughness){
	float NH = max(dot(N,H),0);
	float alpha = Roughness*Roughness;
	float R_2 = alpha*alpha;
	float denominator = NH*NH * (R_2 - 1) + 1;
	return R_2/(PI * denominator * denominator);
}

vec3 BRDF(vec3 albedo, vec3 N,vec3 L,vec3 H, vec3 V, float roughness, float metalness, vec3 F, float KD){
	vec3 diff = albedo/PI;
	vec3 spec = f_Specular(N, L, H, V, roughness, metalness, F);
	return (KD*diff+(1-KD)*(1-metalness)*spec);
}

vec4 CalculatePoint(Light light, vec3 normal, vec3 position, vec3 albedo, float roughness, float metalness)
{
	vec3 F = vec3(F0);
    vec3 L = light.position - position;
    vec3 V = viewPos - position;
    vec3 H = normalize(L+V);
    float dis = length(L);
	L = normalize(L);
	V = normalize(V);

    float visibility = 1.0f;

    return vec4(
		BRDF(albedo.rgb, normal, L, H, V, roughness, metalness, F, 0.4f)
		*(1.0f/(0.01f+0.05f*dis+0.1* dis*dis)), 
	visibility);
}


vec4 CalculateDirectLighting(vec3 position, vec3 normal, vec3 albedo, float roughness, float metalness)
{
    normal = normalize(normal);
    // world space grid voxel size
    float voxelWorldSize = 1.0 /  (voxelScale * volumeDimension);
    // calculate directional lighting
    vec4 directLighting = vec4(0.0f, 0.0f, 0.0f, 0.0f);
    vec4 current =  vec4(0.0f); int count = 0;
	// move position forward to avoid shadowing errors
    position = position + normal * voxelWorldSize * 0.5f;

    // calculate lighting for point lights
    for(int i = 0; i < lightCount; ++i)
    {
        current = CalculatePoint(pointLight[i], normal, position, albedo, roughness, metalness);
        directLighting.rgb += current.rgb;
        directLighting.a += current.a; count++;
    }

    if(count > 0) { directLighting.a /= count; }

    return directLighting;
}

vec3 EncodeNormal(vec3 normal)
{
    return normal * 0.5f + vec3(0.5f);
}

vec3 DecodeNormal(vec3 normal)
{
    return normal * 2.0f - vec3(1.0f);
}
