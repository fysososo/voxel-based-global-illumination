#version 430
#extension GL_ARB_shader_image_load_store : require
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(binding = 0) uniform sampler3D voxelAlbedo;
layout(binding = 1, rgba8) uniform image3D voxelNormal;
layout(binding = 2, rgba8) uniform image3D readonly voxelEmisson;
layout(binding = 3) uniform sampler3D voxelRoughness;
layout(binding = 4) uniform sampler3D voxelMetalness;

layout(binding = 5, rgba8) uniform image3D writeonly voxelRadiance;
//调试用缓存
layout(binding = 6, rgba16f) uniform image3D debug_comp_injectRandiance;

//计算宏
const float PI = 3.14159265f;
const float EPSILON = 1e-30;
const float SQRT_3 = 1.73205080f;

//参数
uniform vec3 viewPos;
uniform float F0;
uniform float traceShadowHit = 0.5f;

//灯光
/*点光源衰减参数*/
struct Attenuation
{
    float constant;
    float linear;
    float quadratic;
};
/*灯光结构体*/
struct Light {
    Attenuation attenuation;
    vec3 diffuse;
    vec3 direction;
    vec3 position;
};
/*灯光信息*/
const uint MAX_POINT_LIGHTS = 6;
uniform Light pointLight[MAX_POINT_LIGHTS];
uniform int lightCount;

//体素信息
uniform float voxelSize;
uniform float voxelScale;
uniform vec3 worldMinPoint;
uniform int volumeDimension;


//BRDF
float D(vec3 N, vec3 H, float Roughness);
vec3 F(vec3 H, vec3 V, vec3 F0);
float G_direct(vec3 N, vec3 I, float Roughness);
float G_ibl(vec3 N, vec3 I, float Roughness);
vec3 f_Specular(vec3 N,vec3 L,vec3 H, vec3 V, float Roughness, float metalness, vec3 F0);
vec3 BRDF(vec3 albedo, vec3 N,vec3 L,vec3 H, vec3 V, float Roughness, float metalness, vec3 F0, float KD);
vec3 BRDF_t(Light light, vec3 normal, vec3 albedo);

vec3 VoxelToWorld(ivec3 pos);
vec3 WorldToVoxel(vec3 position);
vec4 CalculatePoint(Light light, vec3 normal, vec3 position, vec3 albedo, float roughness, float metalness);
vec4 CalculateDirectLighting(vec3 position, vec3 normal, vec3 albedo, float roughness, float metalness);
vec3 EncodeNormal(vec3 normal);
vec3 DecodeNormal(vec3 normal);

void main()
{
	if(gl_GlobalInvocationID.x >= volumeDimension ||
		gl_GlobalInvocationID.y >= volumeDimension ||
		gl_GlobalInvocationID.z >= volumeDimension) return;

	ivec3 writePos = ivec3(gl_GlobalInvocationID);

	vec4 albedo = texelFetch(voxelAlbedo, writePos, 0);
    vec3 emission = imageLoad(voxelEmisson, writePos).rgb;
    if(albedo.a < EPSILON) { return; }
    albedo.a = 0.0f;

    vec3 normal = imageLoad(voxelNormal, writePos).xyz;
    normal = DecodeNormal(normal);

    //不计算原本颜色就为零的部分
    if(any(greaterThan(albedo.rgb, vec3(0.0f))))
    {
        //获取世界空间下体素的坐标
        vec3 wsPosition = VoxelToWorld(writePos);
        //将直接光照注入至体素中
        float metalness = texelFetch(voxelMetalness, writePos, 0).r;
	    float roughness = texelFetch(voxelRoughness, writePos, 0).r;
        albedo = CalculateDirectLighting(wsPosition, normal, albedo.rgb, roughness, metalness);
        albedo.a = 1.0f;
    }
    if(any(greaterThan(emission, vec3(0.0f)))){
        albedo.rgb += emission.rgb;
        albedo.a = 1.0f;
    }
	imageStore(voxelRadiance, writePos, albedo);
}

float TraceShadow(vec3 position, vec3 direction, float maxTracingDistance) 
{
    //阴影的尺寸因子
    float k = traceShadowHit * traceShadowHit;
    //一个voxel的在纹理坐标下的尺寸
    float voxelTexSize = 1.0f / volumeDimension;
    //向前移动避免自碰撞
    float dst = voxelTexSize * 2.0f;
    vec3 samplePos = direction * dst + position;
    //最终结果
    float visibility = 0.0f;
    //追踪过程中的积累值
    float traceSample = 0.0f;
    
    while (visibility <= 1.0f && dst <= maxTracingDistance) 
    {
        if (samplePos.x < 0.0f || samplePos.y < 0.0f || samplePos.z < 0.0f
            || samplePos.x > 1.0f || samplePos.y > 1.0f || samplePos.z > 1.0f) 
        { 
            break; 
        }
        //采样
        traceSample = ceil(texture(voxelAlbedo, samplePos).a) * k;
        if(traceSample > 1.0f - EPSILON) { return 0.0f; }

        //积累
        visibility += (1.0f - visibility) * traceSample / dst;
        //step
        dst += voxelTexSize;
        samplePos = direction * dst + position;
    }
    return 1.0f - visibility;
}


vec3 VoxelToWorld(ivec3 pos)
{
    vec3 result = vec3(pos);
    result *= voxelSize;

    return result + worldMinPoint;
}

vec3 WorldToVoxel(vec3 position)
{
    vec3 voxelPos = position - worldMinPoint;
    return voxelPos * voxelScale;
}

vec3 F(vec3 H, vec3 V, vec3 F0){
	return F0 + (1-F0)*pow(1-max(dot(H, V), 0.0), 5);
}

float G_direct(vec3 N, vec3 I, float Roughness){
	float NI = max(dot(N,I),0);
	float k = pow(Roughness+1.0f,2)/8.0f;
	return NI/(NI*(1-k)+k);
}

float G_ibl(vec3 N, vec3 I, float Roughness){
	float NI = max(dot(N,I),0);
	float alpha = Roughness*Roughness;
	float R_2 = alpha*alpha;
	float k = R_2/8.0f;
	return NI/(NI*(1-k)+k);
}

vec3 f_Specular(vec3 N,vec3 L,vec3 H, vec3 V, float Roughness, float metalness, vec3 F0){
	float NV = max(dot(V,N), 0);
	float NL = max(dot(L,N),0);
	return (D(N,H,Roughness)*F(H,V,F0)*G_direct(N,L,Roughness)*G_direct(N,V,Roughness))/(4.0f*NV*NL + 0.001f);
}


float D(vec3 N, vec3 H, float Roughness){
	float NH = max(dot(N,H),0);
	float alpha = Roughness*Roughness;
	float R_2 = alpha*alpha;
	float denominator = NH*NH * (R_2 - 1) + 1;
	return R_2/(PI * denominator * denominator);
}

vec3 BRDF(vec3 albedo, vec3 N,vec3 L,vec3 H, vec3 V, float roughness, float metalness, vec3 F, float KD){
	vec3 diff = albedo/PI;
	vec3 spec = f_Specular(N, L, H, V, roughness, metalness, F);
	return (KD*diff+(1-KD)*(1-metalness)*spec);
}

vec3 BRDF_t(Light light, vec3 normal, vec3 albedo)
{
    float nDotL = 0.0f;
    vec3 weight = normal * normal;
        
    float rDotL = dot(vec3(1.0, 0.0, 0.0), light.direction);
    float uDotL = dot(vec3(0.0, 1.0, 0.0), light.direction);
    float fDotL = dot(vec3(0.0, 0.0, 1.0), light.direction);

    rDotL = normal.x > 0.0 ? max(rDotL, 0.0) : max(-rDotL, 0.0);
    uDotL = normal.y > 0.0 ? max(uDotL, 0.0) : max(-uDotL, 0.0);
    fDotL = normal.z > 0.0 ? max(fDotL, 0.0) : max(-fDotL, 0.0);
       
    nDotL = rDotL * weight.x + uDotL * weight.y + fDotL * weight.z;

    return light.diffuse * albedo * nDotL;
}

vec4 CalculatePoint(Light light, vec3 normal, vec3 position, vec3 albedo, float roughness, float metalness)
{
    light.direction = light.position - position;
    float d = length(light.direction);
    light.direction = normalize(light.direction);
    
    //点光源衰减
    float falloff = 1.0f / (light.attenuation.constant + light.attenuation.linear * d
                    + light.attenuation.quadratic * d * d + 1.0f);
    if(falloff <= 0.0f) return vec4(0.0f);

    //计算contraceShadow生成的可视度
    vec3 voxelPos = WorldToVoxel(position);
    vec3 lightPosT = WorldToVoxel(light.position);
    vec3 lightDirT = lightPosT.xyz - voxelPos.xyz;
    float dT = length(lightDirT);
    lightDirT = normalize(lightDirT);
    float visibility = TraceShadow(voxelPos, lightDirT, dT);
    
    imageStore(debug_comp_injectRandiance, ivec3(gl_GlobalInvocationID), vec4(visibility));
    //注意处理负值
    if(visibility <= 0.0f) return vec4(0.0f);
    //计算BRDF
    //vec3 brdf = BRDF(albedo.rgb, normal, L, H, V, roughness, metalness, F, 0.4f)*max(dot(normal, L),0.0f);
    vec3 brdf = BRDF_t(light, normal, albedo.rgb);
    return vec4(
		brdf
        *visibility
        *falloff
		, visibility);
}


vec4 CalculateDirectLighting(vec3 position, vec3 normal, vec3 albedo, float roughness, float metalness)
{
    normal = normalize(normal);
    //世界坐标下的体素尺寸
    float voxelWorldSize = 1.0 /  (voxelScale * volumeDimension);
    //辅助用变量
    vec4 directLighting = vec4(0.0f);
    vec4 current =  vec4(0.0f);int count = 0;
    //先沿法线移动一定距离，防止阴影错位
    position = position + normal * voxelWorldSize * 0.5f;
    //接着计算此处体素颜色，rgb为颜色，a为该体素的可视度
    for(int i = 0; i < lightCount; ++i)
    {
        current = CalculatePoint(pointLight[i], normal, position, albedo, roughness, metalness);
        directLighting.rgb += current.rgb;
        directLighting.a += current.a; count++;
    }
    if(count > 0) { directLighting.a /= count; }
    return directLighting;
}

vec3 EncodeNormal(vec3 normal)
{
    return normal * 0.5f + vec3(0.5f);
}

vec3 DecodeNormal(vec3 normal)
{
    return normal * 2.0f - vec3(1.0f);
}
