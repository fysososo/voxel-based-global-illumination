#version 430
#extension GL_ARB_shader_image_load_store : require
layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(binding = 0, rgba8) uniform coherent image3D voxelAlbedo;
layout(binding = 1, rgba8) uniform coherent image3D voxelNormal;
layout(binding = 2, rgba8) uniform coherent image3D voxelEmisson;
layout(binding = 3, rgba8) uniform coherent image3D voxelRoughness;
layout(binding = 4, rgba8) uniform coherent image3D voxelMetalness;
layout(binding = 5, rgba8) uniform coherent image3D voxelRadiance;

//计算宏
const float PI = 3.14159265f;
const float EPSILON = 1e-30;
const float SQRT_3 = 1.73205080f;

//参数
uniform vec3 viewPos;
uniform float F0;

//灯光
struct Light {
    vec3 position;
	vec3 color;
	float intensity;
};
const uint MAX_POINT_LIGHTS = 6;
uniform Light pointLight[MAX_POINT_LIGHTS];
uniform int lightCount;

//体素信息
uniform float voxelSize;
uniform float voxelScale;
uniform vec3 worldMinPoint;
uniform int volumeDimension;


//BRDF
float D(vec3 N, vec3 H, float Roughness);
vec3 F(vec3 H, vec3 V, vec3 F0);
float G_direct(vec3 N, vec3 I, float Roughness);
float G_ibl(vec3 N, vec3 I, float Roughness);
vec3 f_Specular(vec3 N,vec3 L,vec3 H, vec3 V, float Roughness, float metalness, vec3 F0);
vec3 BRDF(vec3 albedo, vec3 N,vec3 L,vec3 H, vec3 V, float Roughness, float metalness, vec3 F0, float KD);
vec3 BRDF_t(Light light, vec3 normal, vec3 albedo, vec3 direction);

vec3 VoxelToWorld(ivec3 pos);
vec3 WorldToVoxel(vec3 position);
vec4 CalculatePoint(Light light, vec3 normal, vec3 position, vec3 albedo, float roughness, float metalness);
vec4 CalculateDirectLighting(vec3 position, vec3 normal, vec3 albedo, float roughness, float metalness);
vec3 EncodeNormal(vec3 normal);
vec3 DecodeNormal(vec3 normal);

void main()
{
	if(gl_GlobalInvocationID.x >= volumeDimension ||
		gl_GlobalInvocationID.y >= volumeDimension ||
		gl_GlobalInvocationID.z >= volumeDimension) return;

	ivec3 writePos = ivec3(gl_GlobalInvocationID);

	vec4 result = vec4(0.0f);

	vec4 albedo = vec4(imageLoad(voxelAlbedo, writePos).xyz,1.0f);
	vec3 baseNormal = DecodeNormal(imageLoad(voxelNormal, writePos).xyz);
	vec4 emission = vec4(imageLoad(voxelEmisson, writePos).xyz, 1.0f);
	float metalness = imageLoad(voxelMetalness, writePos).r;
	float roughness = imageLoad(voxelRoughness, writePos).r;
    vec3 wsPosition = VoxelToWorld(writePos);
    //result = albedo;
    result = CalculateDirectLighting(wsPosition, baseNormal, albedo.rgb, roughness, metalness);

    result.rgb += emission.rgb;
    result.a = 1.0f;

	imageStore(voxelRadiance, writePos, result);
}

vec3 VoxelToWorld(ivec3 pos)
{
    vec3 result = vec3(pos);
    result *= voxelSize;

    return result + worldMinPoint;
}

vec3 WorldToVoxel(vec3 position)
{
    vec3 voxelPos = position - worldMinPoint;
    return voxelPos * voxelScale;
}

vec3 F(vec3 H, vec3 V, vec3 F0){
	return F0 + (1-F0)*pow(1-max(dot(H, V), 0.0), 5);
}

float G_direct(vec3 N, vec3 I, float Roughness){
	float NI = max(dot(N,I),0);
	float k = pow(Roughness+1.0f,2)/8.0f;
	return NI/(NI*(1-k)+k);
}

float G_ibl(vec3 N, vec3 I, float Roughness){
	float NI = max(dot(N,I),0);
	float alpha = Roughness*Roughness;
	float R_2 = alpha*alpha;
	float k = R_2/8.0f;
	return NI/(NI*(1-k)+k);
}

vec3 f_Specular(vec3 N,vec3 L,vec3 H, vec3 V, float Roughness, float metalness, vec3 F0){
	float NV = max(dot(V,N), 0);
	float NL = max(dot(L,N),0);
	return (D(N,H,Roughness)*F(H,V,F0)*G_direct(N,L,Roughness)*G_direct(N,V,Roughness))/(4.0f*NV*NL + 0.001f);
}


float D(vec3 N, vec3 H, float Roughness){
	float NH = max(dot(N,H),0);
	float alpha = Roughness*Roughness;
	float R_2 = alpha*alpha;
	float denominator = NH*NH * (R_2 - 1) + 1;
	return R_2/(PI * denominator * denominator);
}

vec3 BRDF(vec3 albedo, vec3 N,vec3 L,vec3 H, vec3 V, float roughness, float metalness, vec3 F, float KD){
	vec3 diff = albedo/PI;
	vec3 spec = f_Specular(N, L, H, V, roughness, metalness, F);
	return (KD*diff+(1-KD)*(1-metalness)*spec);
}

vec3 BRDF_t(Light light, vec3 normal, vec3 albedo, vec3 direction)
{
    float nDotL = 0.0f;
    vec3 weight = normal * normal;
        
    float rDotL = dot(vec3(1.0, 0.0, 0.0), direction);
    float uDotL = dot(vec3(0.0, 1.0, 0.0), direction);
    float fDotL = dot(vec3(0.0, 0.0, 1.0), direction);

        rDotL = normal.x > 0.0 ? max(rDotL, 0.0) : max(-rDotL, 0.0);
        uDotL = normal.y > 0.0 ? max(uDotL, 0.0) : max(-uDotL, 0.0);
        fDotL = normal.z > 0.0 ? max(fDotL, 0.0) : max(-fDotL, 0.0);
       
        nDotL = rDotL * weight.x + uDotL * weight.y + fDotL * weight.z;

    return albedo * nDotL;
}

vec4 CalculatePoint(Light light, vec3 normal, vec3 position, vec3 albedo, float roughness, float metalness)
{
	vec3 F = mix(vec3(F0), albedo.rgb, metalness);
    float dis = length(light.position - position);
    vec3 L = normalize(light.position - position);
    vec3 V = normalize(viewPos - position);
    vec3 H = normalize(L+V);
    float visibility = 1.0f;
    float attenuation = 1.0 / (dis * dis);
	vec3 radiance = light.color * attenuation * light.intensity; 
    return vec4(
		BRDF(albedo.rgb, normal, L, H, V, roughness, metalness, F, 0.4f)
		*max(dot(normal, L),0.0f)
        *radiance
		, visibility);
}


vec4 CalculateDirectLighting(vec3 position, vec3 normal, vec3 albedo, float roughness, float metalness)
{
    normal = normalize(normal);
    // world space grid voxel size
    float voxelWorldSize = 1.0 /  (voxelScale * volumeDimension);
    // calculate directional lighting
    vec4 directLighting = vec4(0.0f, 0.0f, 0.0f, 0.0f);
    vec4 current =  vec4(0.0f); 
	int count = 0;

    // calculate lighting for point lights
    for(int i = 0; i < lightCount; ++i)
    {
        current = CalculatePoint(pointLight[i], normal, position, albedo, roughness, metalness);
        directLighting.rgb += current.rgb;
    }


    return directLighting;
}

vec3 EncodeNormal(vec3 normal)
{
    return normal * 0.5f + vec3(0.5f);
}

vec3 DecodeNormal(vec3 normal)
{
    return normal * 2.0f - vec3(1.0f);
}
